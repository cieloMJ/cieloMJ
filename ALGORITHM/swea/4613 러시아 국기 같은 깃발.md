### 풀이
```
T = int(input())
for tc in range(1, T+1):
    N, M = map(int, input().split())
    flag = [list(input()) for _ in range(N)]
    min_cnt = float('inf')

    chk = [[0]*3 for _ in range(N)]
    for i in range(N):
        chk[i][0] = M-flag[i].count('W')
        chk[i][1] = M-flag[i].count('B')
        chk[i][2] = M-flag[i].count('R')

    cnt = 0
    for k in range(N-2):
        for s in range(k+1, N-1):
            cnt = sum(chk[r][0] for r in range(k+1)) + sum(chk[r][1] for r in range(k+1, s+1)) + sum(chk[r][2] for r in range(s+1, N))
            min_cnt = min(cnt, min_cnt)

    print(min_cnt)
```

처음에 생각한 방법은 맨 위를 W, 맨 아래를 R로 고정해둔 채
남은 줄을 절반으로 나누어 위쪽은 W와 B를 변경했을 때 최소 변경 개수, 아래 쪽은 R과 B 중 최소 변경 개수
이런 식으로 구하려고 했다.

```
T = int(input())
for tc in range(1, T+1):
    N, M = map(int, input().split())
    flag = [list(input()) for _ in range(N)]
    cnt = 2*M - flag[0].count('W') - flag[-1].count('R')

    if N > 3:
        for i in range(1, N-1):
            if flag[i].count('W')>flag[i].count('B'):
                cnt += M-flag[i].count('W')
            else:
                start_i = i
                break

        for j in range(start_i, N-1):
            if flag[j].count('R')>flag[j].count('B'):
                cnt += M-flag[j].count('R')
            else:
                cnt += M-flag[j].count('B')
                start_j = j + 1
                break

        if start_j and start_j < N-1:
            for k in range(start_j, N-1):
                cnt += M-flag[k].count('B')

    else:
        cnt += M-flag[1].count('B')
    print(cnt)
```

그러다보니

1. for j in range(start_i, N-1): 반복문에서 break가 한 번도 발생하지 않으면 start_j가 생성되지 않음
2. 경계 분리 불안정성, 중간값이 계산될 수 있음
3. 단순 비교로 최소 변경 횟수가 계산되지 않을 수 있음
등 다양한 문제가 발생한다.
실제 예제 문제 답안조차도 제대로 실행이 되지 않았다.

그래서 다시 처음부터 생각하여 각 줄마다 W, B, R 변경 횟수를 계산하고 
range 범위를 조절하여 모든 경우의 수를 확인하였다.
