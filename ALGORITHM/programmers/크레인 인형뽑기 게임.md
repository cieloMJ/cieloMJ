### 풀이
```
def solution(board, moves):
    
    n = len(board)
    cnt = 0
    bag = []
    
    for i in moves:
        k = i-1
        for j in range(n):
            if board[j][k] != 0:
                doll = board[j][k]
                board[j][k] = 0
                if bag and bag[-1] == doll:
                    bag.pop()
                    cnt += 2
                else:
                    bag.append(doll)
                break
    return cnt
```

우선 moves에 담긴 값들이 인덱스 +1 값이기 때문에 숫자 1개를 뽑을 때마다 인덱스에 맞게 k에 할당했다.
또한, 모든 값 중에서 특정 k번째 열의 값을 뽑아야 하기 때문에,위와 같이 board[j][k]의 값을 확인했다.
뽑을 경우, 해당 값을 0으로 할당해야 하기 때문에 해당 값을 우선 doll에 넣어둔 뒤, 추가 확인 단계를 진행했다.

해당 문제에서 어려움을 느꼈던 부분은, 
우선 열로 접근해야 한다는 생각 때문에 zip 함수를 쓰고자 하니 오히려 헷갈리게 되었다.
그래서 익숙한 인덱스로 접근하여 해당 문제를 해결했다.

또한, 첫 번째에 풀지 못한 이유는 cnt += 1로 하여 기댓값과 다르게 나왔기 때문이다.
처음에는 동일한 인형(같은 숫자)가 2번 연속된 경우를 하나의 케이스로 계산했으나,
문제에서는 없어진 인형 수이기 때문에 +2인 것이 올바른 풀이였다.

