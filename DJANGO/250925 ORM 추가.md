## 단일 게시글 조회

: 상세 페이지를 만드는 것

```python
# articles/urls.py

urlpatterns = [
	path('', views.index, name='index'),
	path('<int:pk>/', views.detail, name='detail'),
]
```

```python
# articles/views.py

# 전체 게시글 조회(1) 후 메인 페이지 응답(2)
def index(request):
    # 1. DB에 전체 게시글을 조회
    articles = Article.objects.all()

    # 2. 전체 게시글 목록을 템플릿과 함께 응답
    context = {
        'articles': articles,
    }
    return render(request, 'articles/index.html', context)

# 게시글 상세 페이지를 응답하는 함수
# 해야 할 일
## 1. 몇 번 게시글인 지를 DB에 조회
## 2. 조회한 상세 게시글 데이터를 템플릿과 함께 응답해야 함
def detail(request, pk):
    # 1. 단일 게시글 조회
    # queryset API method -> get()
    article = Article.objects.get(pk=pk)

    # 2. 단일 게시글 데이터와 템플릿을 응답
    context = {
        'article': article,
    }
    return render(request, 'articles/detail.html', context)
```

```html
<!-- templates/articles/detail.html -->

<body>
  <h1>Detail</h1>
  <h2>{{ article.pk }}번째 글</h2>
  <hr>
  <p>제목: {{ article.title }}</p>
  <p>내용: {{ article.content }}</p>
  <p>작성일: {{ article.created_at }}</p>
  <p>수정일: {{ article.updated_at }}</p>
  <hr>
  <a href="{% url "articles:index" %}"> [메인 페이지로]</a>
</body>
```

단일 게시글 이동 페이지 링크 구현

```html
<!-- templates/articles/index.html -->

<body>
  <h1>메인 페이지</h1>
  <hr>
  {% comment %} 전체 게시글 출력 {% endcomment %}
  {% for article in articles %}
    <p>글 번호: {{ article.pk }}</p>
    <a href="{% url "articles:detail" article.pk %}">글 제목: {{ article.title }}</a>
    <p>글 내용: {{ article.content }}</p>
    <hr>
  {% endfor %}
</body>
```

### Create

- 로직 구현 시 필요한 view 함수 개수 : 2가지
    1. New 
        
        : 사용자 입력 데이터를 받을 페이지 rendering
        
    2. Create
    : 사용자가 입력한 요청 데이터를 받아 DB에 저장

구현

1. 페이지 렌더링
→ 게시글 생성 페이지 구현
    
    ```html
    # articles/urls.py
    
    urlpatterns = [
        path('', views.index, name='index'),
        path('<int:pk>/', views.detail, name='detail'),
        path('new/', views.new, name='new'),
    ]
    ```
    
    ```html
    # articles/views.py
    
    # 사용자가 게시글 생성을 위한 작성 페이지를 응답하는 함수
    def new(request):
        return render(request, 'articles/new.html')
    ```
    
    ```html
    
    <!-- templates/articles/new.html -->
    
    <body>
      <h1>New</h1>
      <form action="{% url "articles:create" %}" method="GET">
        <div>
          <label for="title">Title: </label>
          <input type="text" name="title" id="title">
        </div>
        <div>
          <label for="content">Content: </label>
          <textarea name="content" id="content"></textarea>
        </div>
        <input type="submit">
      </form>
      <hr>
      <a href="{% url 'articles:index' %}">[back]</a>
    </body>
    ```
    

![image.png](attachment:899f0438-622e-4f89-938b-07af0b93887e:image.png)

```html
<!-- templates/articles/index.html -->

<body>
  <h1>Articles</h1>
  <a href="{% url 'articles:new' %}">New</a>
  <hr>
  ...
```

1. 데이터 저장 기능

```python
# articles/urls.py

urlpatterns = [
    path('', views.index, name='index'),
    path('<int:pk>/', views.detail, name='detail'),
    path('new/', views.new, name='new'),
    path('create', views.create, name='create'),
]

```

```html
<!-- templates/articles/create.html -->

<body>
  <h1>게시글 생성 완료</h1>
</body>
```

```python
# articles/views.py

def create(request):
    
    # 1. 사용자로부터 입력 받은 데이터 추출
    title = request.GET.get('title')
    content = request.GET.get('content')

    # 2. 추출한 데이터를 데이터베이스에 저장
    # ## 2_1
    # article = Article()
    # article.title = title
    # article.content = content
    # article.save()

    ## 2_2
    article = Article(title=title, content=content)
    article.save()

    # ## 2_3
    # Article.objects.create(title=title, content=content)

    # 3. 저장 이후에 저장이 완료되었다는 응답 페이지 응답
    
    return render(request, 'articles/create.html')
```

- DB에 저장하는 방법 3가지
    - 바로 저장해도 상관 없는 경우,
    create( ) 메서드를 사용해서 추출한 데이터를 DB에 저장하면 됨.
    - 반면, 
    1번과 2번의 경우 데이터를 정비하는 단계와 저장하는 단계가 분리되어 있음.
        - 저장 (save( )) 전에 추가 단계를 넣을 수 있음
            - 유효성 검사
                - 사용자 입력 데이터를 받는 경우,
                개발자가 입력하는 것이 아니기 때문에 잘못 작성하거나 오류 발생 등의 위험성 존재
                → 이러한 데이터에 대해 유효한 지에 대한 검사가 필요함
            - 추가 데이터 삽입 등
        - 2번은 1번의 데이터 정비 과정을 한 줄로 표현한 것 뿐

### HTTP request methods

**개념**

- 데이터에 대해 수행을 원하는 작업(행동)을 나타내는 것
    - 서버에게 원하는 작업 종류를 알려주는 역할
    - HTTP : 네트워크 상에서 데이터(리소스)를 주고 받기 위한 약속

**대표 메서드** 

- GET
    
    **개념**
    
    - 리소스 조회
        - 서버로부터 **데이터를 요청**하고 받아오는 데 사용 (**조회**)
        - 검색 쿼리 전송, 웹 페이지 요청, API에서 데이터를 조회 등
    - 단순히 **데이터 조회**에서만 사용
    ( 어떠한 데이터를 담아서 전달하기에 부적합 )
    - 특징
        1. 데이터 전송
            - URL의 쿼리 문자열(Query String)을 통해 데이터 전송
                - URL에 데이터가 노출됨
                    - http://127.0.0.1:8000/articles/create/?title=제목&content=내용
                    - 뜨면 안되는 경우 존재 → 사용 불가
                    ex. 로그인 페이지
                - URL에 담을 수 없는 데이터가 있을 수 있음
                    - 동영상, 사진 등 다양한 데이터를 주고 받을 수 있지만 URL에 문자열만 들어갈 수 있기 때문에 URL에 담을 수 없음
        2. 데이터 제한
            - URL 길이에 제한이 있어 대량의 데이터 전송에는 적합하지 않음
                - 데이터를 모두 넣을 수 없을 정도로 길어질 수 있음
        3. 브라우저 히스토리
            - 브라우저 히스토리에 남음 → 뒤로 가기 등 활용 가능
        4. 캐싱 가능
            - 캐싱이란? 
            자주 사용하는 데이터나 결과를 임시로 저장해두고 재활용하여 처리 속도를 높이는 기술
            - 브라우저 : GET 요청의 응답을 로컬에 저장 가능
                
                동일 URL로 다시 요청 시, 서버에 접속하지 않고 저장된 결과 사용
                → 페이지 로딩 시간 크게 단축
                

- POST
    
    **개념**
    
    - 데이터 생성 / 전송
        - 서버에 데이터를 제출하여 리소스를 변경(생성, 수정, 삭제)하는 데 사용
        - 서버로 데이터를 전송하여 서버의 상태를 변경할 때 사용
        - 로그인 정보 제출, 파일 업로드, 새 데이터 생성(ex. 새 게시글 작성), API에서 데이터 변경 요청 등
    - 데이터 생성이나 수정에 주로 사용
    - 특징
        1. 데이터 전송
            - HTTP Body를 통해 데이터 전송
                - 요청 본문에서 데이터 전송
                - 데이터 노출 없음
        2. 데이터 제한
            - GET method보다 더 많은 데이터 전송 가능
                - 큰 용량이나 동영상, 이미지 등 다양한 데이터가 들어갈 수 있음
        3. 브라우저 히스토리
            - 브라우저 히스토리에 남지 X → 뒤로 가기 사용 불가
        4. 캐싱 불가
            - 일반적으로 서버의 상태를 변경하는 작업을 수행하기 때문에 캐시 사용 불가
                - 서버로 전송하면 끝인 것
    

### HTTP response status code

**개념**

- 서버가 클라이언트의 요청에 대한 처리 결과를 나타내는 3자리 숫자
- 해당 코드를 통해 요청의 성공 여부, 혹은 추가 조치가 필요한지 즉시 파악 가능
    
    → 웹브라우저 : 사용자에게 적절한 메시지 표시 
    → 개발자 : 문제 해결을 위한 단서 획득
    
- 예시
    - 404 Error
    - 403 Forbidden
        - 의미 : 서버에 요청이 전달되었지만, 권한 때문에 거절됨
        - 예시
            
            : new.html의 form 요청은 새로운 article, 즉 새로운 데이터를 생성하는 요청
            
            → POST method로 서버에 전달되는 것이 적합함
            
        
        ```html
        
        <!-- templates/articles/new.html -->
        
        <body>
          <h1>New</h1>
          <form action="{% url "articles:create" %}" **method="POST"**>
            <div>
              <label for="title">Title: </label>
              <input type="text" name="title" id="title">
            </div>
            <div>
              <label for="content">Content: </label>
              <textarea name="content" id="content"></textarea>
            </div>
            <input type="submit">
          </form>
          <hr>
          <a href="{% url 'articles:index' %}">[back]</a>
        </body>
        ```
        
        ```python
        def create(request):
            
            # 1. 사용자로부터 입력 받은 데이터 추출
            title = request**.POST**.get('title')
            content = request.POST.get('content')
        ```
        
        ![image.png](attachment:e0a96d91-ef62-4a05-878a-4d18f251bf69:image.png)
        
        - token을 주지 않아서 실패함을 알 수 있음
            - why?
                
                사이트 간 요청 위조 (Cross-Site-Request-Forgery; **CSRF**) 
                
                - 사용자가 자신의 의지와는 무관하게 공격자(해커)가 의도한 행동을 특정 웹사이트에 요청하게 만드는 해킹 방식
                    - 해커의 대리인으로서 사용자가 특정 웹 사이트를 공격한 것
                    - 위조된 인감도장이라고 해석할 수 있음
                - 공격에 대한 방어 : **CSRF 토큰**
                    
                        **{% csrf_token %}**    
                    
                    - Django가 제공하는 일회용 비밀 코드
                    - 새로고침을 하면 다른 코드로 바뀌게 됨
                    - 위의 태그를 사용하여 손쉽게 토큰 값 부여
                        - 요청 시 토큰 값도 함께 서버로 전송될 수 있도록 처리
            
            ![새로고침하면 없어짐](attachment:972d5422-07d6-4b84-b38f-75c1acd999f6:593dba2e-e207-46a2-9dc4-74b229e9ee5f.png)
            
            새로고침하면 없어짐
            
            ```html
            <!-- templates/articles/new.html -->
            
            <body>
              <h1>New</h1>
              <form action="{% url "articles:create" %}" method="POST">
                **{% csrf_token %}**
                <div>
                  <label for="title">Title: </label>
                  <input type="text" name="title" id="title">
                </div>
                <div>
                  <label for="content">Content: </label>
                  <textarea name="content" id="content"></textarea>
                </div>
                <input type="submit">
              </form>
              <hr>
              <a href="{% url 'articles:index' %}">[back]</a>
            </body>
            ```
            

### Redirect

개념

- 클라이언트가 인자에 작성된 주소로 다시 요청을 보내도록 하는 함수
    
    ```python
    # articles/views.py
    from django.shortcuts import render, redirect
    
    '''
    
    def create(request):
    	title = request.POST.get('title')
    	content = request.POST.get('content')
    	article = Article(title=title, content=content)
    	article.save()
    	return redirect('articles:detail', article.pk)
    ```
    
    ```python
    # 메인 페이지
    return redirect('articles/index')
    
    # 상세 페이지
    return redirect('articles:detail', article.pk)
    ```
    

### Delete

: 상세 페이지에서 delete 버튼 만들기

```python
# articles/urls.py

urlpatterns = [
	...
	path('<int:pk>/delete/', views.delete, name='delete'),
]
```

```python
# articles/views.py

def delete(request, pk):
	article = Article.objects.get(pk=pk)
	article.delete()
	return redirect('articles:index')
```

```html
<!-- articles/detail.html -->

<body>
	<h1> Detail </h1>
	...
	<hr>
	<form action="{% url 'articles:delete' article.pk %}" method="POST">
		{% csrf token %}
		<input type="submit" value="DELETE">
	</form>
	<a href="{% url 'articles:index' %}">[back]</a>
</body>
```

### Update

- Update 로직을 구현하기 위해 필요한 view 함수 개수 : 2개
    - edit : 사용자의 입력 데이터를 받을 페이지 렌더링
    - update : 사용자가 입력한 요청 데이터를 받아 DB에 저장
    
- Edit 구현 로직
    
    ```python
    # articles/urls.py
    
    urlpatterns = [
    	...
    	path('<int:pk>/edit/', views.edit, name='edit'),
    ]
    ```
    
    ```python
    # articles/views.py
    
    def edit(request, pk):
    	article = Article.object.get(pk=pk)
    	context = {
    		'article' : article,
    	}
    	return render(request, 'articles/edit.html', context)
    ```
    
    ```html
    <!-- articles/edit.html -->
    
    <body>
    	<h1> Detail </h1>
    	<form action="#" method = "POST">
    		{% csrf_token %}
    		<div>
    			<label for "title"> Title: </label>
    			<input type="text" name="title" id="title" value="{{ articles.title }}">
    		</div>
    		<div>
    			<label for "content"> Content: </label>
    			<textarea name="content" id="content">{{ articles.content }}</textarea>
    		</div>
    		<input type="submit">
    	</form>
    	<hr>
    	<a href="{% url 'articles:index' %}">[back]</a>
    ```
    
    ```html
    <!-- articles/detail.html -->
    
    <body>
    ...
    	<a href="{% url 'articles:edit' article.pk %}">EDIT</a><br>
    	<form action="{% url 'articles:delete' article.pk %}" method="POST">
    		{% csrf_token %}
    		<input type="submit" value="DELETE">
    	</form>
    	<a href="{% url 'articles:index' %}">[back]</a>
    </body>
    ```
    
- Update 구현 로직
